## HTTP2.0

### HTTP各个版本:

🎄**http/0.9** :只支持get方法，不支持多媒体内容的 MIME 类型、各种 HTTP 首部，或者版本号，只是为了获取html对象。

🌸**http/1.0** :添加了版本号、各种 HTTP 首部、一些额外的方法，以及对多媒体对象的处理。

🍄**http/1.0+** :keep-alive 连接、虚拟主机支持，以及代理连接支持都被加入到 HTTP 之中等等。

🍁**http/1.1**: 重点关注的是校正 HTTP 设计中的结构性缺陷，明确语义，引入重要 的性能优化措施，并删除一些不好的特性：如Entity tag，If-Unmodified-Since, If-Match, If-None-Match；请求头引入了range头域，它允许只请求资源的某个部分（206）；新增了更多的状态码；Host头处理（400）

🌺**HTTP/2.0** 被寄予了如下期望:

* 相比于使用 TCP 的 HTTP/1.1，最终用户可感知的多数延迟都有能够量化的显 著改善;

* 解决 HTTP 中的队头阻塞问题;

* 并行的实现机制不依赖与服务器建立多个连接，从而提升 TCP 连接的利用率，特别是在拥塞控制方面;

* 保留 HTTP/1.1 的语义，可以利用已有的文档资源(如上所述)，包括(但不限于):HTTP 方法、状态码、URI 和首部字段;

* 明确定义 HTTP/2.0 和 HTTP/1.x 交互的方法，特别是通过中介时的方法(双向);

* 明确指出它们可以被合理使用的新的扩展点和策略。



### HTTP2.0到底有什么



#### http/2.0 分层

http/2 大致可以分为两部分:分帧层，即 h2 多路复用能力的核心部分;数据或 http 层,其中包含传统上被认为是 HTTP 及其关联数据的部分。 

* 二进制协议：

   h2 的分帧层是基于帧的二进制协议。这方便了机器解析，但是肉眼识别起来比较困难。

* 首部压缩：

  仅仅使用二进制协议似乎还不够，h2 的首部还会被深度压缩。这将显著减少传输中的冗余字节 

*  多路复用 ：

  在你喜爱的调试工具里查看基于 h2 传输的连接的时候，你会发现请求和响应交织在一起。

*  加密传输：

  线上传输的绝大部分数据是加密过的，所以在中途读取会更加困难。

#### 连接

连接是所有 HTTP/2 会话的基础元素，其定义是客户端初始化的一个 TCP/IP socket，客户端 是指发送 HTTP 请求的实体。这和 h1 是一样的，不过与完全无状态的 h1 不同的是，h2 把它所承载的帧(frame)和流(stream)共同依赖的连接层元素捆绑在一起，其中既包含连接层设置也包含首部表。 

>  **判断是否支持http/2.0**
> 🍏协议发现——识别终端是否支持你想使用的协议——会比较棘手。HTTP/2 提供两种协
>  议发现的机制。
>
>  🍐在连接不加密的情况下，客户端会利用 Upgrade 首部来表明期望使用 h2。如果服务器 也可以支持 h2，它会返回一个“101 Switching Protocols”(协议转换)响应。这增加了 一轮完整的请求-响应通信。
>
> 🍑如果连接基于 TLS，情况就不同了。客户端在 ClientHello 消息中设置 ALPN (Application-Layer Protocol Negotiation，应用层协议协商)扩展来表明期望使用 h2 协 议，服务器用同样的方式回复。

为了向服务器双重确认客户端支持 h2，客户端会发送一个叫作 connection preface(连接 前奏)的魔法字节流，作为连接的第一份数据。这主要是为了应对客户端通过纯文本的 HTTP/1.1 升级上来的情况。该字节流用十六进制表示如下:

```
0x505249202a20485454502f322e300d0a0d0a534d0d0a0d0a
```

解码为 ASCII 是:

```
PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n 
```

这个字符串的用处是，如果服务器(或者中间网络设备)不支持 h2，就会产生一个显式错误。这个消息特意设计成 h1 消息的样式。如果运行良好的 h1 服务器收到这个字符串，它会阻塞这个方法(PRI)或者版本(HTTP/2.0)，并返回错误，可以让 h2 客户端明确地知道发生了什么错误。 

这个魔法字符串会有一个 ***SETTINGS\*** **帧**紧随其后。服务器为了确认它可以支持 h2，会声明收到客户端的 ***SETTINGS 帧\***，并返回一个它自己的 ***SETTINGS 帧***(反过来也需要确认)， 然后确认环境正常，可以开始使用 h2。 (注意⚠️：***SETTINGS\*** **帧是个非常重要的帧，http/2.0有十几个帧，不同的帧代表不一样的状态功能**)



#### 帧

HTTP/2 是基于帧(frame)的协议。采用分帧是为了将重要信息都封装起来，让协议的解析方可以轻松阅读、解析并还原信息。 相比之下，h1 不是基于帧的，而是以 文本分隔。 看看下面的简单例子:

```
GET / HTTP/1.1 <crlf>
Host: www.example.com <crlf>
Connection: keep-alive <crlf>
Accept: text/html,application/xhtml+xml,application/xml;q=0.9... <crlf>
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4)... <crlf>
Accept-Encoding: gzip, deflate, sdch <crlf>
Accept-Language: en-US,en;q=0.8 <crlf>
Cookie: pfy_cbc_lb=p-browse-w; customerZipCode=99912|N; ltc=%20;...<crlf> 
```

解析这种数据用不着什么高科技，但往往速度慢且容易出错。你需要不断读入字节，直到 遇到分隔符为止(这里是指 <crlf>)，同时还要考虑一些不太守规矩的客户端，它们会只 发送 <lf>。



https://juejin.im/post/5da16e9ef265da5b76373d0e#heading-2